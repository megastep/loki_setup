*************************************************************************
*** Applied ***
Date: Tue, 18 Apr 2000 07:54:24 +0200
From: "Jeroen Janssen" <japj@oce.nl>
Subject: getting the install source path (cdrom) from within (pre/post)
         installation scripts?

Hello,

I'm working on an updated OpenUT setup and I need access to the source path
(of the installation cdrom) in order to apply some xdelta based patches
during the install (xdelta needs the original files from cdrom and applies a
binary diff to it). Since the destination path & symlink path are already
put in the scripts environment I was wondering if it's also possible to add
the install source path to the environment.

I attached a simple patch that *should* do the trick (unfortunately I can't
test it here, so I hope it doesn't break anything), you might want to think
about a different environment variable name & mupltiple/no CDROM support.

Best regards,

Jeroen Janssen

diff -u -r setup-1.2/install.c setup-1.2-jeroenj/install.c
--- setup-1.2/install.c	Fri Mar 10 02:20:38 2000
+++ setup-1.2-jeroenj/install.c	Tue Apr 18 13:21:06 2000
@@ -814,12 +814,15 @@
                 "SETUP_PRODUCTVER=\"%s\"\n"
                 "SETUP_INSTALLPATH=\"%s\"\n"
                 "SETUP_SYMLINKSPATH=\"%s\"\n"
-                "export SETUP_PRODUCTNAME SETUP_PRODUCTVER SETUP_INSTALLPATH SETUP_SYMLINKSPATH\n"
+                "SETUP_CDROMPATH=\"%s\"\n"
+                "export SETUP_PRODUCTNAME SETUP_PRODUCTVER SETUP_INSTALLPATH SETUP_SYMLINKSPATH SETUP_CDROMPATH\n"
                 "%s\n",
                 info->name, info->version,
                 info->install_path,
                 info->symlinks_path,
-                script);
+                cdroms[0],  // return first available CDROM (check? do we HAVE a CDROM?)
+                script); 
+                
         fchmod(fileno(fp),0755); /* Turn on executable bit */
         fclose(fp);
         if ( arg >= 0 ) {
*************************************************************************
*** Applied ***
Date: Mon, 14 Feb 2000 12:24:32 -0700
From: "Troy A. Griffitts" <scribe@crosswire.org>
Subject: desktops, icons, etc.

I've made the desktop location code a little more intuitive for gnome
and kde.

There is a new destop: REDHAT where info is stored in /etc/Xll/applnk. 
Redhat intends for this to work in both the gnome and kde worlds, but
kde is not handled well as of 6.1, so KDE icons are still installed
regardless if a redhat desktop is found.

There are also new options on binary nodes to specify the 'name' on the
icon and to what sub-'menu' the icon will be intalled (created if
necessary).  This handles multiple binaries much better.
eg.

    <binary arch="any" libc="any" symlink="app1"
menu="Applications/MyProject" name="Application 1" icon="app1icon.xpm">
      app1
    </binary>
    <binary arch="any" libc="any" symlink="app2"
menu="Applications/MyProject" name="Application 2" icon="app2icon.xpm">
      app2
    </binary>

Everything should still default to 'Games' and such, if none of these
extra options are used.

Again, hope these are useful.  I'm not sure if I'm being more of a
burden then a help on this list.  Would you like me to continue posting
patches or should we just maintain our own branch and, if you are
interested, you may check our CVS repository?  Let me know.  I don't
mind either.

        -Troy.

Index: copy.c
===================================================================
RCS file: /usr/local/cvsroot/setup/copy.c,v
retrieving revision 1.3
diff -u -r1.3 copy.c
--- copy.c	2000/02/11 18:34:04	1.3
+++ copy.c	2000/02/14 19:07:38
@@ -615,6 +615,8 @@
             }
             add_bin_entry(info, final, symlink,
                                        xmlGetProp(node, "desc"),
+                                       xmlGetProp(node, "menu"),
+                                       xmlGetProp(node, "name"),
                                        xmlGetProp(node, "icon"));
         }
     }
Index: install.c
===================================================================
RCS file: /usr/local/cvsroot/setup/install.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 install.c
--- install.c	2000/02/06 01:04:01	1.1.1.1
+++ install.c	2000/02/14 19:07:41
@@ -7,12 +7,14 @@
 #include <pwd.h>
 #include <unistd.h>
 #include <signal.h>
+#include <stdio.h>
 
 #include "install.h"
 #include "install_log.h"
 #include "detect.h"
 #include "log.h"
 #include "copy.h"
+#include "file.h"
 #include "network.h"
 
 extern char *rpm_root;
@@ -214,7 +216,8 @@
 
 /* Add a binary entry to the list of binaries installed */
 void add_bin_entry(install_info *info, const char *path,
-                   const char *symlink, const char *desc, const char *icon)
+                   const char *symlink, const char *desc, const char *menu,
+                   const char *name, const char *icon)
 {
     struct bin_elem *elem;
 
@@ -224,6 +227,8 @@
         if ( elem->path ) {
             elem->symlink = symlink;
             elem->desc = desc;
+            elem->menu = menu;
+            elem->name = name;
             elem->icon = icon;
             elem->next = info->bin_list;
             info->bin_list = elem;
@@ -376,8 +381,10 @@
     copy_tree(info, node, info->install_path, update);
     if(info->options.install_menuitems){
       int i;
-      for(i = 0; i<MAX_DESKTOPS; i++)
-        install_menuitems(info, i);
+      for(i = 0; i<MAX_DESKTOPS; i++) {
+        if (install_menuitems(info, i))
+          break;
+        }
     }
     generate_uninstall(info);
     return SETUP_COMPLETE;
@@ -570,64 +577,110 @@
     return SETUP_EXIT;
 }
 
+static const char* redhat_app_links[] =
+{
+    "/etc/X11/applnk/",
+    0
+};
+
+
 static const char* kde_app_links[] =
 {
-    "/usr/share/applnk/Games/",
-    "/opt/kde/share/applnk/Games/",
+    "/usr/share/applnk/",
+    "/opt/kde/share/applnk/",
     "~/.kde/share/applnk/",
     0
 };
 
+
 static const char* gnome_app_links[] =
 {
-    "/usr/share/gnome/apps/Games/",
-    "/opt/gnome/apps/Games/",
+    "/usr/share/gnome/apps/",
+    "/usr/local/share/gnome/apps/",
+    "/opt/gnome/share/gnome/apps/",
     "~/.gnome/apps/",
     0
 };
 
 /* Install the desktop menu items */
-void install_menuitems(install_info *info, desktop_type desktop)
+char install_menuitems(install_info *info, desktop_type desktop)
 {
     const char **app_links;
     char buf[PATH_MAX];
     struct bin_elem *elem;
+    char ret_val = 0;
+    const char *desk_base;
+    char icon_base[PATH_MAX];
+    const char *found_links[3];
+    FILE *fp;
 
     switch (desktop) {
+        case DESKTOP_REDHAT:
+            app_links = redhat_app_links;
+            break;
         case DESKTOP_KDE:
-            app_links = kde_app_links;
+            desk_base = getenv("KDEDIR");
+            if (desk_base) {
+                sprintf(icon_base, "%s/share/applnk/", desk_base); 
+                found_links[0] = icon_base;
+                found_links[1] = "~/.kde/share/applnk/";
+                found_links[2] = 0;
+                app_links = found_links;
+            }
+            else {
+                app_links = kde_app_links;
+            }
             break;
         case DESKTOP_GNOME:
-            app_links = gnome_app_links;
+            fp = popen("gnome-config --prefix", "r");
+            if (fp) {
+                fgets(icon_base, PATH_MAX, fp);
+                icon_base[strlen(icon_base)-1]=0;
+                strcat(icon_base, "/share/gnome/apps/");
+                found_links[0] = icon_base;
+                found_links[1] = "~/.gnome/apps/";
+                found_links[2] = 0;
+                app_links = found_links;
+            }
+            else {
+                app_links = gnome_app_links;
+            }
             break;
         default:
-            return;
+            return ret_val;
     }
+
     for( ; *app_links; app_links ++){
         expand_home(info, *app_links, buf);
+
         if ( access(buf, W_OK) < 0 )
             continue;
 
         for (elem = info->bin_list; elem; elem = elem->next ) {      
             FILE *fp;
+            char finalbuf[PATH_MAX];
+
+            sprintf(finalbuf, "%s%s/", buf, (elem->menu) ? elem->menu : "Games");
+            file_create_hierarchy(info, finalbuf);
 
             /* Presumably if there is no icon, no desktop entry */
             if ( (elem->icon == NULL) || (elem->symlink == NULL) ) {
                 continue;
             }
-            strncat(buf, elem->symlink, PATH_MAX);
+            strncat(finalbuf, elem->symlink, PATH_MAX);
             switch(desktop){
                 case DESKTOP_KDE:
-                    strncat(buf,".kdelnk", PATH_MAX);
+                    strncat(finalbuf,".kdelnk", PATH_MAX);
                     break;
+                case DESKTOP_REDHAT:
                 case DESKTOP_GNOME:
-                    strncat(buf,".desktop", PATH_MAX);
+                    strncat(finalbuf,".desktop", PATH_MAX);
                     break;
                 default:
                     break;
             }
 
-            fp = fopen(buf, "w");
+            fp = fopen(finalbuf, "w");
             if (fp) {
                 char exec[PATH_MAX], icon[PATH_MAX];
 
@@ -644,16 +697,22 @@
                              "Terminal=0\n"
                              "Type=Application\n",
                              (desktop==DESKTOP_KDE) ? "KDE " : "",
-                             info->name, info->desc,
+                             elem->name, info->desc,
                              exec, icon
                              );
                 fclose(fp);
-                add_file_entry(info, buf);
+                add_file_entry(info, finalbuf);
+
+                // successful REDHAT takes care of KDE/GNOME
+                // tell caller no need to continue others
+                ret_val = (desktop == DESKTOP_REDHAT);
+
             } else {
-                log_warning(info, "Unable to create desktop file '%s'", buf);
+                log_warning(info, "Unable to create desktop file '%s'", finalbuf);
             }
         }
     }
+    return ret_val;
 }
 
 /* Run some shell script commands */
Index: install.h
===================================================================
RCS file: /usr/local/cvsroot/setup/install.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 install.h
--- install.h	2000/02/06 01:04:03	1.1.1.1
+++ install.h	2000/02/14 19:07:42
@@ -33,7 +33,8 @@
 
 /* The types of desktop we support menu items for */
 typedef enum {
-    DESKTOP_KDE,
+    DESKTOP_KDE, // KDE first because RH6.1 does not yet handle KDE well.
+    DESKTOP_REDHAT,
     DESKTOP_GNOME,
 	MAX_DESKTOPS
 	/* More to come ? */
@@ -102,6 +103,8 @@
         char *path;
         const char *symlink;
         const char *desc;
+        const char *menu;
+        const char *name;
         const char *icon;
         struct bin_elem *next;
     } *bin_list;
@@ -164,7 +167,8 @@
 
 /* Add a binary entry to the list of binaries installed */
 extern void add_bin_entry(install_info *info, const char *path,
-                const char *symlink, const char *desc, const char *icon);
+                   const char *symlink, const char *desc, const char *menu,
+                   const char *name, const char *icon);
 
 /* Expand a path with home directories into the provided buffer */
 extern void expand_home(install_info *info, const char *path, char *buffer);
@@ -209,7 +213,7 @@
 extern int launch_browser(install_info *info, int (*browser)(const char *url));
 
 /* Install the desktop menu items */
-extern void install_menuitems(install_info *info, desktop_type d);
+extern char install_menuitems(install_info *info, desktop_type d);
 
 /* Run shell script commands from a string
    If 'arg' is >= 0, it is passed to the script as a numeric argument,

*************************************************************************
*** Applied ***
Date: Fri, 11 Feb 2000 12:07:39 -0700
From: "Troy A. Griffitts" <scribe@crosswire.org>
Subject: setup patches

Sam,

    I've added another feature that we needed that I feel will be useful
to others.  We're keeping a copy on our CVS server if you would like to
grab a patched copy.  I'm also attaching the patch.  It expects the
previous patch that I sent to already be applied.

The new feature allows syntax like the following

...
        <files path=${KDEDIR|/usr/local}/share>
                kdesharebase.tar.gz
        </files>
...

This parses any ${ENVVAR} token and replaces it with the environment
variable value.  You may also specify a default value if the environment
variable is not set: ${ENVVAR|default_value}

Hope this is useful.

our anonymous cvs info:

$ export CVSROOT=:pserver:anonymous@cvs.crosswire.org:/usr/local/cvsroot
$ cvs login
Password: anonymous
$ cvs checkout setup

Thanks again for a great tool!

        -Troy A. Griffitts
        http://www.crosswire.org

Index: copy.c
===================================================================
RCS file: /usr/local/cvsroot/setup/copy.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -u -r1.1 -r1.3
--- copy.c	2000/02/06 01:03:56	1.1
+++ copy.c	2000/02/11 18:34:04	1.3
@@ -34,11 +34,29 @@
 static char current_option[200];
 extern char *rpm_root;
 
+void getToken(const char *src, const char **end) {
+    *end = 0;
+    while (*++src) {
+        if (*src == '}') {
+            *end = src;
+            break;
+        }
+    }
+}
+
 int parse_line(const char **srcpp, char *buf, int maxlen)
 {
     const char *srcp;
     char *dstp;
+    const char *subst = 0;
+    char *tokenval = 0;
+    char *token = 0;
+    const char *end;
 
+    if (!*srcpp) { // assert
+        *buf = 0;
+        return 0;
+    }
     /* Skip leading whitespace */
     srcp = *srcpp;
     while ( *srcp && isspace(*srcp) ) {
@@ -47,12 +65,33 @@
 
     /* Copy the line */
     dstp = buf;
-    while ( *srcp && (*srcp != '\r') && (*srcp != '\n') ) {
+    while ( (*srcp || subst) && (*srcp != '\r') && (*srcp != '\n') ) {
         if ( (dstp-buf) >= maxlen ) {
             break;
         }
+        if (!*srcp && subst) { // if we're substituting and done
+            srcp = subst;
+            subst = 0;
+        }
+        if ((!subst) && (*srcp == '$') && (*(srcp+1) == '{')) {
+            getToken(srcp+2, &end);
+            if (end) {	// we've got a good token
+                if (token) free(token);
+                token = calloc((end-(srcp+2))+1, 1);
+                memcpy(token, srcp+2, (end-(srcp+2)));
+                strtok(token, "|"); // in case a default val is specified
+                tokenval = getenv(token);
+                if (!tokenval) // if no env set, check for default
+                    tokenval = strtok(0, "|");
+                if (tokenval) {
+                    subst = end+1;  // where to continue after tokenval
+                    srcp = tokenval;
+                }
+            }
+        }
         *dstp++ = *srcp++;
     }
+    if (token) free(token);
 
     /* Trim whitespace */
     while ( (dstp > buf) && isspace(*(dstp-1)) ) {
@@ -591,6 +630,7 @@
                 void (*update)(install_info *info, const char *path, size_t progress, size_t size, const char *current))
 {
     size_t size, copied;
+    char tmppath[PATH_MAX];
 
     size = 0;
     node = node->childs;
@@ -598,6 +638,10 @@
         const char *path = xmlGetProp(node, "path");
         if (!path)
             path = dest;
+        else {
+            parse_line(&path, tmppath, PATH_MAX);
+            path = tmppath;
+        }
 /* printf("Checking node element '%s'\n", node->name); */
         if ( strcmp(node->name, "files") == 0 ) {
             const char *str = xmlNodeListGetString(info->config, (node->parent)->childs, 1);
@@ -643,6 +687,7 @@
                 void (*update)(install_info *info, const char *path, size_t progress, size_t size, const char *current))
 {
     size_t size, copied;
+    char tmppath[PATH_MAX];
 
     size = 0;
     while ( node ) {
@@ -651,8 +696,13 @@
         wanted = xmlGetProp(node, "install");
         if ( wanted  && (strcmp(wanted, "true") == 0) ) {
             const char *deviant_path = xmlGetProp(node, "path");
-            copied = copy_node(info, node,
-                (deviant_path) ? deviant_path : info->install_path, update);
+            if (!deviant_path)
+                deviant_path = info->install_path;
+            else {
+                parse_line(&deviant_path, tmppath, PATH_MAX);
+                deviant_path = tmppath;
+            }
+            copied = copy_node(info, node, deviant_path, update);
             if ( copied > 0 ) {
                 size += copied;
             }
Index: gtk_ui.c
===================================================================
RCS file: /usr/local/cvsroot/setup/gtk_ui.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -u -r1.1 -r1.3
--- gtk_ui.c	2000/02/06 01:03:59	1.1
+++ gtk_ui.c	2000/02/11 18:34:04	1.3
@@ -253,16 +253,19 @@
 char check_deviant_paths(xmlNodePtr node)
 {
     char path_up[PATH_MAX];
+
     while ( node ) {
         const char *wanted;
-        const char *deviant_path;
+        const char *dpath;
+        char deviant_path[PATH_MAX];
 
         wanted = xmlGetProp(node, "install");
         if ( wanted  && (strcmp(wanted, "true") == 0) ) {
             xmlNodePtr elements = node->childs;
             while ( elements ) {
-                deviant_path = xmlGetProp(elements, "path");
-                if ( deviant_path ) {
+                dpath = xmlGetProp(elements, "path");
+                if ( dpath ) {
+                parse_line(&dpath, deviant_path, PATH_MAX);
                     topmost_valid_path(path_up, deviant_path);
                     if (access(path_up, W_OK) < 0 )
                         return 1;
*************************************************************************
*** Applied ***
Date: Sat, 05 Feb 2000 14:41:09 -0700
From: "Troy A. Griffitts" <scribe@crosswire.org>
Subject: setup patches

Sam and Stephane,
        Here are some more patches to the setup util.  I haven't had much
time to work on it, but these were quick and should provide some useful
features.

        I've added a path="/deviant/path/" option to option components. 
This allows an install developer to place components like:
        <files path="/usr/lib">
                libbase.tar.gz
        </files>
        <files path="/usr/share">
                sharebase.tar.gz
        </files>

When all other components still install into the user's selected
directory, these 'deviant' entries will install to the set locations.

The gtk_ui checks write permission for these paths if the option is
selected before enabling install.

diff -Pru setup-1.1.orig/copy.c setup-1.1/copy.c
--- setup-1.1.orig/copy.c	Wed Dec  1 16:15:26 1999
+++ setup-1.1/copy.c	Fri Feb  4 01:38:17 2000
@@ -595,21 +595,36 @@
     size = 0;
     node = node->childs;
     while ( node ) {
+        const char *path = xmlGetProp(node, "path");
+        if (!path)
+            path = dest;
 /* printf("Checking node element '%s'\n", node->name); */
         if ( strcmp(node->name, "files") == 0 ) {
             const char *str = xmlNodeListGetString(info->config, (node->parent)->childs, 1);
             parse_line(&str, current_option, sizeof(current_option));
             copied = copy_list(info,
                                xmlNodeListGetString(info->config, node->childs, 1),
-                               dest, update);
+                               path, update);
             if ( copied > 0 ) {
                 size += copied;
             }
         }
+        if ( strcmp(node->name, "xfonts") == 0 ) {
+            if (info->copy_xfonts) {
+                const char *str = xmlNodeListGetString(info->config, (node->parent)->childs, 1);
+                parse_line(&str, current_option, sizeof(current_option));
+                copied = (*info->copy_xfonts)(info,
+                            xmlNodeListGetString(info->config, node->childs, 1),
+                            update);
+                if ( copied > 0 ) {
+                    size += copied;
+                }
+            }
+        }
         if ( strcmp(node->name, "binary") == 0 ) {
             copied = copy_binary(info, node,
                                xmlNodeListGetString(info->config, node->childs, 1),
-                               dest, update);
+                               path, update);
             if ( copied > 0 ) {
                 size += copied;
             }
@@ -617,7 +632,7 @@
         if ( strcmp(node->name, "script") == 0 ) {
             copy_script(info, node,
                         xmlNodeListGetString(info->config, node->childs, 1),
-                        dest);
+                        path);
         }
         node = node->next;
     }
@@ -635,7 +650,9 @@
 
         wanted = xmlGetProp(node, "install");
         if ( wanted  && (strcmp(wanted, "true") == 0) ) {
-            copied = copy_node(info, node, info->install_path, update);
+            const char *deviant_path = xmlGetProp(node, "path");
+            copied = copy_node(info, node,
+                (deviant_path) ? deviant_path : info->install_path, update);
             if ( copied > 0 ) {
                 size += copied;
             }
diff -Pru setup-1.1.orig/gtk_ui.c setup-1.1/gtk_ui.c
--- setup-1.1.orig/gtk_ui.c	Wed Dec  1 16:15:26 1999
+++ setup-1.1/gtk_ui.c	Fri Feb  4 01:38:17 2000
@@ -230,26 +231,64 @@
     cur_state = SETUP_INSTALL;
 }
 
+
+void topmost_valid_path(char *target, const char *src) {
+    char *cp;
+  
+    /* Get the topmost valid path */
+    strcpy(target, src);
+    if ( target[0] == '/' ) {
+        cp = target+strlen(target);
+        while ( access(target, F_OK) < 0 ) {
+            while ( (cp > (target+1)) && (*cp != '/') ) {
+                --cp;
+            }
+            *cp = '\0';
+        }
+    }
+}
+
+
+/* returns true if any deviant paths are not writable */
+char check_deviant_paths(xmlNodePtr node)
+{
+    char path_up[PATH_MAX];
+    while ( node ) {
+        const char *wanted;
+        const char *deviant_path;
+
+        wanted = xmlGetProp(node, "install");
+        if ( wanted  && (strcmp(wanted, "true") == 0) ) {
+            xmlNodePtr elements = node->childs;
+            while ( elements ) {
+                deviant_path = xmlGetProp(elements, "path");
+                if ( deviant_path ) {
+                    topmost_valid_path(path_up, deviant_path);
+                    if (access(path_up, W_OK) < 0 )
+                        return 1;
+                }
+                elements = elements->next;
+            }
+            if (check_deviant_paths(node->childs))
+                return 1;
+        }
+        node = node->next;
+    }
+    return 0;
+}
+
+
 /* Checks if we can enable the "Begin install" button */
 static void check_install_button(void)
 {
     const char *message;
     GtkWidget *options_status;
     GtkWidget *button_install;
-    char path_up[PATH_MAX], *cp;
+    char path_up[PATH_MAX];
     struct stat st;
   
     /* Get the topmost valid path */
-    strcpy(path_up, cur_info->install_path);
-    if ( path_up[0] == '/' ) {
-        cp = path_up+strlen(path_up);
-        while ( access(path_up, F_OK) < 0 ) {
-            while ( (cp > (path_up+1)) && (*cp != '/') ) {
-                --cp;
-            }
-            *cp = '\0';
-        }
-    }
+    topmost_valid_path(path_up, cur_info->install_path);
  
     /* See if we can install yet */
     message = "";
@@ -265,6 +304,8 @@
         message = "Install path is not a directory";
     } else if ( access(path_up, W_OK) < 0 ) {
         message = "No write permissions on the install directory";
+    } else if ( check_deviant_paths(cur_info->config->root->childs) ) {
+        message = "No write permissions to install a selected package";
     } else if ( cur_info->symlinks_path[0] &&
                (access(cur_info->symlinks_path, W_OK) < 0) ) {
         message = "No write permissions on the binary directory";
@@ -743,7 +787,7 @@
     gtk_label_set_text(GTK_LABEL(widget), info->install_path);
     widget = glade_xml_get_widget(setup_glade, "play_game_label");
     if ( info->installed_symlink ) {
-        sprintf(text, "Type '%s' to play the game", info->installed_symlink);
+        sprintf(text, "Type '%s' to start the program", info->installed_symlink);
     } else {
         strcpy(text, "");
     }
**********************************************************************************
****** Applied

Index: README.xml
===================================================================
RCS file: /cvs/setup/README.xml,v
retrieving revision 1.29
diff -u -r1.29 README.xml
--- README.xml	2000/07/31 21:27:08	1.29
+++ README.xml	2000/08/04 03:02:21
@@ -117,6 +117,12 @@
             path for binaries. Set this when this installation won't
             actually install any binary file.
 
+ promptbinaries     When set to "yes", setup will create a checkbox
+                    to allow the user whether or not to create 
+                    a symbolic link to the binaries.
+
+                    This setting has no effect if nobinaries is "yes".
+
  meta       When this attribute is set to "yes", then setup will act as
             a meta-installer, i.e. it will allow the user to select a
             product and set-up will respawn itself for the selected
@@ -145,6 +151,29 @@
 
 There is also no need to have the files designated by those tags explicitly
 installed in a FILES section, setup will take care of that for you.
+
+
+The INSTALL_DROP_LIST element:
+
+The install_drop_list element makes it possible to override the default
+installation paths supplied in the Installation target drop down box.
+
+Supply a list of drop down paths, space or new line separated.
+An example follows:
+
+    <install_drop_list>
+        /opt /usr/local
+        /var
+        ~
+    </install_drop_list>
+
+If no install_drop_list element is given, it will default to hard coded
+values (see install.c).
+
+Note:  Your paths will not be displayed if they are not valid,
+writable paths.
+
+
 
 The OPTION element:
 
Index: console_ui.c
===================================================================
RCS file: /cvs/setup/console_ui.c,v
retrieving revision 1.36
diff -u -r1.36 console_ui.c
--- console_ui.c	2000/08/02 22:37:47	1.36
+++ console_ui.c	2000/08/04 03:02:21
@@ -37,9 +37,7 @@
                        char *answer, int maxlen)
 {
     printf("%s", prompt);
-    if ( default_answer && *default_answer ) {
-        printf(" [%s] ", default_answer);
-    }
+    printf(" [%s] ", default_answer && *default_answer ? default_answer : "");
     fflush(stdout);
     if ( fgets(answer, maxlen, stdin) ) {
         answer[strlen(answer)-1] = '\0';
@@ -287,6 +285,7 @@
     char path[PATH_MAX];
     xmlNodePtr node;
 
+
 	if ( GetProductIsMeta(info) ) {
 		while ( ! okay ) {
 			int index = 1, chosen;
@@ -363,15 +362,36 @@
 				}
 			}
 
+                        /* Default to empty */
+                        path[0] = '\0';
+
 			/* Find out where to install the binary symlinks, unless the binary path
 			   was provided as a command line argument */
-			if ( ! disable_binary_path ) {
-				if ( ! GetProductHasNoBinaries(info) ) {
-					if ( ! prompt_user(_("Please enter the path for binary installation"),
-									   info->symlinks_path, path, sizeof(path)) ) {
-						return SETUP_ABORT;
-					}
-				}
+			if ( ! disable_binary_path ) 
+                        {
+                            int get_path = 1;
+
+                            if (GetProductHasNoBinaries(info))
+                                get_path = 0;
+
+                            if (get_path)
+                            {
+                                /*----------------------------------------
+                                **  Optionally, ask the user whether
+                                **    they want to create a symlink
+                                **    to the path or not.
+                                **--------------------------------------*/
+                                if (GetProductHasPromptBinaries(info))
+                                    if (console_prompt(_("Do you want to install symbolic links to a directory in your path?"), RESPONSE_YES) != RESPONSE_YES)
+                                        get_path = 0;
+                            }
+
+                            if (get_path)
+                                if ( ! prompt_user(_("Please enter the path in which to create the symbolic links"),
+                                                                   info->symlinks_path, path, sizeof(path)) ) {
+                                        return SETUP_ABORT;
+                                }
+
 			} else {
 				printf(_("Binary path set to: %s\n"), info->symlinks_path);
 				strcpy(path, info->symlinks_path);
@@ -387,14 +407,15 @@
 			/* Check permissions on the symlinks path, if the path was 
 			   provided as a command-line argument and it invalid, then
 			   abort  */
-			if ( access(info->symlinks_path, W_OK) < 0 ) {
-				printf(_("No write permission to %s\n"), info->symlinks_path);
-				if (! disable_binary_path) {
-					continue;
-				} else {
-					return SETUP_ABORT;
-				}
-			}
+                        if (strlen(info->symlinks_path) > 0)
+                            if ( access(info->symlinks_path, W_OK) < 0 ) {
+                                    printf(_("No write permission to %s\n"), info->symlinks_path);
+                                    if (! disable_binary_path) {
+                                            continue;
+                                    } else {
+                                            return SETUP_ABORT;
+                                    }
+                            }
 
 			/* Go through the install options */
 			info->install_size = 0;
Index: gtk_ui.c
===================================================================
RCS file: /cvs/setup/gtk_ui.c,v
retrieving revision 1.44
diff -u -r1.44 gtk_ui.c
--- gtk_ui.c	2000/08/02 22:37:47	1.44
+++ gtk_ui.c	2000/08/04 03:02:22
@@ -109,13 +109,16 @@
 
 /* Globals */
 
-static char *install_paths[] = {
+static char *default_install_paths[] = {
     "/usr/local/games",
     "/opt/games",
     "/usr/games",
     NULL
 };
 
+#define MAX_INSTALL_PATHS       25      /* Use an arbitrary maximum; the lack of
+                                            flexibility shouldn't be an issue */
+static char *install_paths[MAX_INSTALL_PATHS];
 
 /* Various warning dialogs */
 static enum {
@@ -606,6 +609,47 @@
   }
 }
 
+/*-----------------------------------------------------------------------------
+**  on_use_binary_toggled
+**      Signal function to repsond to a toggle state in the
+** 'Use symbolic link' checkbox.
+**---------------------------------------------------------------------------*/
+void on_use_binary_toggled ( GtkWidget* widget, gpointer func_data)
+{
+    GtkWidget *binary_path_widget;
+    GtkWidget *binary_label_widget;
+    GtkWidget *binary_entry;
+    char *string;
+
+    /*-------------------------------------------------------------------------
+    ** Pick up widget handles
+    **-----------------------------------------------------------------------*/
+    binary_path_widget = glade_xml_get_widget(setup_glade, "binary_path");
+    binary_label_widget = glade_xml_get_widget(setup_glade, "binary_label");
+
+    /*-------------------------------------------------------------------------
+    ** Mark the appropriate widgets active or inactive
+    **-----------------------------------------------------------------------*/
+    gtk_widget_set_sensitive(binary_path_widget, GTK_TOGGLE_BUTTON(widget)->active);
+    gtk_widget_set_sensitive(binary_label_widget, GTK_TOGGLE_BUTTON(widget)->active);
+
+    /*-------------------------------------------------------------------------
+    ** Finally, set the symlinks_path.  If we've made it active
+    **      again, we have to go get the current binary entry box
+    **      value and restash it into the global symlinkspath.
+    **-----------------------------------------------------------------------*/
+    if (GTK_TOGGLE_BUTTON(widget)->active)
+    {
+        binary_entry = glade_xml_get_widget(setup_glade, "entry5");
+        string = gtk_entry_get_text( GTK_ENTRY(binary_entry) );
+    }
+    else
+        string = NULL;
+
+    set_symlinkspath(cur_info, string ? string : "");
+}
+
+
 void setup_checkbox_option_slot( GtkWidget* widget, gpointer func_data)
 {
   GtkWidget *window;
@@ -740,6 +784,7 @@
     GList* list;
     int i;
     char path[PATH_MAX];
+    xmlNodePtr node;
 
     widget = glade_xml_get_widget(setup_glade, "install_path");
     
@@ -750,6 +795,67 @@
 
     list = 0;
     list = g_list_append( list, cur_info->install_path);
+
+    /*----------------------------------------------------------------------
+    **  Retrieve the list of install paths from the config file, if we can
+    **--------------------------------------------------------------------*/
+    for (i = 0, node = cur_info->config->root->childs; node;  node = node->next)
+    {
+        if (strcmp(node->name, "install_drop_list") == 0) 
+        {
+            /* Retrieve the value - note that it's up to us to free
+                the memory, which means we can use it without copying it */
+            char *content = xmlNodeGetContent(node);
+            char *p;
+            if (content)
+            {
+                for (p = strtok(content, "\n\t \r\b"); p; 
+                        p = strtok(NULL,"\n\t \r\b" ))
+                {
+                    /*--------------------------------------------------------
+                    **  Expand any ~s in the path
+                    **------------------------------------------------------*/
+                    char *temp_buf;
+                    temp_buf = malloc(PATH_MAX);
+                    if (! temp_buf)
+                    {
+                        fprintf(stderr, "Fatal error:  out of memory\n");
+                        return;
+                    }
+                    expand_home(cur_info, p, temp_buf);
+
+                    if (i > sizeof(install_paths) > sizeof(install_paths[0]))
+                    {
+                        fprintf(stderr, 
+                        "Error: maximum of %d install_path entries exceeded\n",
+                            sizeof(install_paths) > sizeof(install_paths[0]));
+                        return; 
+                    }
+
+                    install_paths[i++] = temp_buf;
+                }
+            }
+        }
+    }
+
+    
+    /*----------------------------------------------------------------------
+    **  If no installation paths were specified, use the default
+    **      values that are hard coded in.
+    **--------------------------------------------------------------------*/
+    if (i == 0)
+        for (i = 0; default_install_paths[i]; ++i)
+            install_paths[i] = default_install_paths[i];
+
+    /*----------------------------------------------------------------------
+    **  Terminate the array
+    **--------------------------------------------------------------------*/
+    install_paths[i] = NULL;
+
+    /*----------------------------------------------------------------------
+    **  Now translate the default install paths into the gtk list,
+    **      avoiding the current default value (which is already in the list)
+    **--------------------------------------------------------------------*/
     for ( i=0; install_paths[i]; ++i ) {
         snprintf(path, sizeof(path), "%s/%s", install_paths[i], GetProductName(cur_info));
         if ( strcmp(path, cur_info->install_path) != 0 ) {
@@ -814,7 +920,9 @@
             if( len && ((sc =strcmp( pc0, cur_info->symlinks_path)) != 0) && (*pc0 != '.') )
             {
               if(!access(pc0, W_OK))
+              {
                 list = g_list_append( list, pc0 );
+              }
             }
 
             if( ! end )
@@ -825,9 +933,15 @@
     if ( list ) {
         gtk_combo_set_popdown_strings( GTK_COMBO(widget), list );
     }
-    if ( change_default && g_list_length(list) ) {
+    if ( change_default && list && g_list_length(list) ) {
         set_symlinkspath(cur_info, g_list_nth(list,0)->data);
     }
+
+    if ((list == NULL || g_list_length(list) == 0) && change_default)
+    {
+        printf("Warning: No writable targets in path...you may want to be root,\n");
+        /* FIXME */
+    }
     gtk_entry_set_text( GTK_ENTRY(GTK_COMBO(widget)->entry), cur_info->symlinks_path );
     return;
 }
@@ -998,6 +1112,7 @@
     GtkWidget *widget;
     GtkWidget *button;
     GtkWidget *install_path, *install_entry, *binary_path, *binary_entry;
+    GtkWidget *symlink_checkbox;
     char title[1024];
 
     cur_state = SETUP_INIT;
@@ -1043,6 +1158,14 @@
     /* add all the other signal handlers defined in setup.glade */
     glade_xml_signal_autoconnect(setup_glade);
 
+    /*---------------------------------------------------------------------------
+    ** Connect a signal handle to control whether or not the symlink
+    **  should be installed
+    **-------------------------------------------------------------------------*/
+    symlink_checkbox = glade_xml_get_widget(setup_glade, "symlink_checkbox");
+    gtk_signal_connect(GTK_OBJECT(symlink_checkbox), "toggled",
+             GTK_SIGNAL_FUNC(on_use_binary_toggled), NULL);
+
     /* Set up the window title */
     window = glade_xml_get_widget(setup_glade, "setup_window");
     snprintf(title, sizeof(title), _("%s Setup"), info->desc);
@@ -1118,6 +1241,18 @@
 		widget = glade_xml_get_widget(setup_glade, "binary_label");
 		if(widget) gtk_widget_hide(widget);
 	}
+
+        /*--------------------------------------------------------------------
+        **  Hide the checkbox allowing the user to pick whether or
+        **      not to install a symlink to the binaries if they
+        **      haven't asked for that feature.
+        **------------------------------------------------------------------*/
+	if (GetProductHasNoBinaries(info) || (!GetProductHasPromptBinaries(info)))
+        {
+            widget = glade_xml_get_widget(setup_glade, "symlink_checkbox");
+            if (widget)
+                gtk_widget_hide(widget);
+        }
 
     /* Realize the main window for pixmap loading */
     gtk_widget_realize(window);
Index: install.c
===================================================================
RCS file: /cvs/setup/install.c,v
retrieving revision 1.57
diff -u -r1.57 install.c
--- install.c	2000/08/02 22:37:47	1.57
+++ install.c	2000/08/04 03:02:22
@@ -139,6 +139,18 @@
 {
 	return xmlGetProp(info->config->root, "nobinaries") != NULL;
 }
+
+int GetProductHasPromptBinaries(install_info *info)
+{
+    char *p = xmlGetProp(info->config->root, "promptbinaries");
+    if (p)
+        if (strstr(p, "yes"))
+            return(1);
+        
+    return(0);
+}
+
+
 const char *GetProductCDROMFile(install_info *info)
 {
     return xmlGetProp(info->config->root, "cdromfile");
Index: install.h
===================================================================
RCS file: /cvs/setup/install.h,v
retrieving revision 1.37
diff -u -r1.37 install.h
--- install.h	2000/07/31 21:47:38	1.37
+++ install.h	2000/08/04 03:02:22
@@ -158,6 +158,7 @@
 extern int         GetProductCDROMRequired(install_info *info);
 extern int         GetProductIsMeta(install_info *info);
 extern int         GetProductHasNoBinaries(install_info *info);
+extern int         GetProductHasPromptBinaries(install_info *info);
 extern const char *GetProductSplash(install_info *info);
 extern const char *GetProductCDROMFile(install_info *info);
 extern const char *GetProductEULA(install_info *info);
Index: image/setup.data/setup.glade
===================================================================
RCS file: /cvs/setup/image/setup.data/setup.glade,v
retrieving revision 1.16
diff -u -r1.16 setup.glade
--- image/setup.data/setup.glade	2000/07/31 21:27:08	1.16
+++ image/setup.data/setup.glade	2000/08/04 03:02:22
@@ -113,7 +113,7 @@
 	    <class>GtkTable</class>
 	    <name>table12</name>
 	    <border_width>5</border_width>
-	    <rows>2</rows>
+	    <rows>3</rows>
 	    <columns>2</columns>
 	    <homogeneous>False</homogeneous>
 	    <row_spacing>5</row_spacing>
@@ -146,32 +146,6 @@
 	    </widget>
 
 	    <widget>
-	      <class>GtkLabel</class>
-	      <name>binary_label</name>
-	      <label>Binary directory:</label>
-	      <justify>GTK_JUSTIFY_CENTER</justify>
-	      <wrap>False</wrap>
-	      <xalign>1</xalign>
-	      <yalign>0.5</yalign>
-	      <xpad>0</xpad>
-	      <ypad>0</ypad>
-	      <child>
-		<left_attach>0</left_attach>
-		<right_attach>1</right_attach>
-		<top_attach>1</top_attach>
-		<bottom_attach>2</bottom_attach>
-		<xpad>0</xpad>
-		<ypad>0</ypad>
-		<xexpand>False</xexpand>
-		<yexpand>False</yexpand>
-		<xshrink>False</xshrink>
-		<yshrink>False</yshrink>
-		<xfill>True</xfill>
-		<yfill>False</yfill>
-	      </child>
-	    </widget>
-
-	    <widget>
 	      <class>GtkCombo</class>
 	      <name>install_path</name>
 	      <value_in_list>False</value_in_list>
@@ -213,6 +187,32 @@
 	    </widget>
 
 	    <widget>
+	      <class>GtkLabel</class>
+	      <name>binary_label</name>
+	      <label>Link path:</label>
+	      <justify>GTK_JUSTIFY_RIGHT</justify>
+	      <wrap>False</wrap>
+	      <xalign>1</xalign>
+	      <yalign>0.5</yalign>
+	      <xpad>0</xpad>
+	      <ypad>0</ypad>
+	      <child>
+		<left_attach>0</left_attach>
+		<right_attach>1</right_attach>
+		<top_attach>2</top_attach>
+		<bottom_attach>3</bottom_attach>
+		<xpad>0</xpad>
+		<ypad>0</ypad>
+		<xexpand>False</xexpand>
+		<yexpand>False</yexpand>
+		<xshrink>False</xshrink>
+		<yshrink>False</yshrink>
+		<xfill>True</xfill>
+		<yfill>False</yfill>
+	      </child>
+	    </widget>
+
+	    <widget>
 	      <class>GtkCombo</class>
 	      <name>binary_path</name>
 	      <value_in_list>False</value_in_list>
@@ -224,8 +224,8 @@
 	      <child>
 		<left_attach>1</left_attach>
 		<right_attach>2</right_attach>
-		<top_attach>1</top_attach>
-		<bottom_attach>2</bottom_attach>
+		<top_attach>2</top_attach>
+		<bottom_attach>3</bottom_attach>
 		<xpad>0</xpad>
 		<ypad>0</ypad>
 		<xexpand>True</xexpand>
@@ -252,6 +252,36 @@
 		<text_max_length>0</text_max_length>
 		<text></text>
 	      </widget>
+	    </widget>
+
+	    <widget>
+	      <class>GtkCheckButton</class>
+	      <name>symlink_checkbox</name>
+	      <can_default>True</can_default>
+	      <has_default>True</has_default>
+	      <can_focus>True</can_focus>
+	      <signal>
+		<name>toggled</name>
+		<handler>on_use_binary_toggled</handler>
+		<last_modification_time>Thu, 03 Aug 2000 09:53:24 GMT</last_modification_time>
+	      </signal>
+	      <label>Install a symbolic link into the path</label>
+	      <active>True</active>
+	      <draw_indicator>True</draw_indicator>
+	      <child>
+		<left_attach>0</left_attach>
+		<right_attach>2</right_attach>
+		<top_attach>1</top_attach>
+		<bottom_attach>2</bottom_attach>
+		<xpad>0</xpad>
+		<ypad>0</ypad>
+		<xexpand>False</xexpand>
+		<yexpand>False</yexpand>
+		<xshrink>False</xshrink>
+		<yshrink>False</yshrink>
+		<xfill>True</xfill>
+		<yfill>False</yfill>
+	      </child>
 	    </widget>
 	  </widget>
 	</widget>

